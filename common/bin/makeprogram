#!/bin/bash

# Copyright 2011 Boris Kogan (boris@thekogans.net)
#
# This file is part of thekogans_toolchain.
#
# thekogans_toolchain is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# thekogans_toolchain is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with thekogans_toolchain. If not, see <http://www.gnu.org/licenses/>.

# This script will configure a directory tree and some
# helpful starter files for a new organization program.

function show_command_help () {
    echo "usage: $0 \
$environment_options \
[[-o | --organization]:organization] \
[-p | --project]:project \
[[-s | --svc]:[svn | git]]"
}

# Create the environment.
if [ "$TOOLCHAIN_ROOT" == "" ]; then
    TOOLCHAIN_COMMON_BIN="$(cd $(dirname ${BASH_SOURCE[0]}) && pwd)"
    if [ ! -e "$TOOLCHAIN_COMMON_BIN"/setenvironment ]; then
        echo "$TOOLCHAIN_COMMON_BIN/setenvironment not found."
        exit 1
    fi
    . "$TOOLCHAIN_COMMON_BIN"/setenvironment "$@"
fi

organization="$TOOLCHAIN_DEFAULT_ORGANIZATION"
project=
svc=

# Parse command line options.
for i in "$@"; do
    case $i in
        -o:*|--organization:*)
            organization="${i#*:}"
            ;;
        -p:*|--project:*)
            project="${i#*:}"
            ;;
        -s:*|--svc:*)
            svc="${i#*:}"
            ;;
    esac
done

# Validate input.
if [ "$organization" == "" ] || [ "$project" == "" ]; then
    echo "Must specify organization and project."
    exit 1
fi

project_root="$DEVELOPMENT_ROOT"/"$organization"/"${project//_//}"
if [ ! -d "$project_root" ]; then
    mkdir -p "$project_root"
    check_errors $?
fi
cd "$project_root"
check_errors $?

if [ "$svc" == "" ]; then
    svc="$(get_default_svc -o:$organization)"
fi
if [ "$svc" == "svn" ]; then
    mkdir trunk branches tags
    check_errors $?
    cd trunk
    check_errors $?
fi
mkdir -p include/"${organization}"/"${project//_//}" src resources doc tests
check_errors $?
if [ "$svc" == "git" ]; then
    touch resources/.keep doc/.keep tests/.keep
    check_errors $?
    cp -v "$TOOLCHAIN_ROOT"/common/resources/.gitignore .gitignore
    check_errors $?
fi
touch README ReleaseNotes
check_errors $?

ORGANIZATION=`echo ${organization} | tr '[:lower:]' '[:upper:]'`
PROJECT=`echo ${project} | tr '[:lower:]' '[:upper:]'`

cat > include/"${organization}"/"${project//_//}"/Options.h << EOF
#if !defined (__${organization}_${project}_Options_h)
#define __${organization}_${project}_Options_h

#include <string>
#include <pugixml/pugixml.hpp>
#include <thekogans/util/Types.h>
#include <thekogans/util/Singleton.h>
#include <thekogans/util/CommandLineOptions.h>
#include <thekogans/util/Directory.h>
#include <thekogans/util/LoggerMgr.h>
#include <thekogans/util/FileLogger.h>

$(begin_namespace -o:$organization -p:$project)

$(indent_namespace -o:$organization -p:$project)/// \struct Options Options.h ${organization}/${project//_//}/Options.h
$(indent_namespace -o:$organization -p:$project)///
$(indent_namespace -o:$organization -p:$project)/// \brief
$(indent_namespace -o:$organization -p:$project)/// Parse command line options.

$(indent_namespace -o:$organization -p:$project)struct Options :
$(indent_namespace -o:$organization -p:$project)        public thekogans::util::Singleton<Options>,
$(indent_namespace -o:$organization -p:$project)        public thekogans::util::CommandLineOptions,
$(indent_namespace -o:$organization -p:$project)        public thekogans::util::Directory::Watcher::EventSink {
$(indent_namespace -o:$organization -p:$project)    /// \brief
$(indent_namespace -o:$organization -p:$project)    /// Display help.
$(indent_namespace -o:$organization -p:$project)    bool help;
$(indent_namespace -o:$organization -p:$project)    /// \brief
$(indent_namespace -o:$organization -p:$project)    /// Display version number.
$(indent_namespace -o:$organization -p:$project)    bool version;
$(indent_namespace -o:$organization -p:$project)    /// \struct Options::LoggerMgr Options.h ${organization}/${project//_//}/Options.h
$(indent_namespace -o:$organization -p:$project)    ///
$(indent_namespace -o:$organization -p:$project)    /// \brief
$(indent_namespace -o:$organization -p:$project)    /// \see{thekogans::util::LoggerMgr} options.
$(indent_namespace -o:$organization -p:$project)    struct LoggerMgr {
$(indent_namespace -o:$organization -p:$project)        /// \brief
$(indent_namespace -o:$organization -p:$project)        /// \see{thekogans::util::LoggerMgr::Level}.
$(indent_namespace -o:$organization -p:$project)        thekogans::util::ui32 level;
$(indent_namespace -o:$organization -p:$project)        /// \brief
$(indent_namespace -o:$organization -p:$project)        /// \see{thekogans::util::LoggerMgr::Decorations}.
$(indent_namespace -o:$organization -p:$project)        thekogans::util::ui32 decorations;
$(indent_namespace -o:$organization -p:$project)        /// \brief
$(indent_namespace -o:$organization -p:$project)        /// true == log to console.
$(indent_namespace -o:$organization -p:$project)        bool consoleLogger;
$(indent_namespace -o:$organization -p:$project)        /// \struct Options::LoggerMgr::FileLogger Options.h ${organization}/${project//_//}/Options.h
$(indent_namespace -o:$organization -p:$project)        ///
$(indent_namespace -o:$organization -p:$project)        /// \brief
$(indent_namespace -o:$organization -p:$project)        /// \see{thekogans::util::FileLogger} options.
$(indent_namespace -o:$organization -p:$project)        struct FileLogger {
$(indent_namespace -o:$organization -p:$project)            /// \brief
$(indent_namespace -o:$organization -p:$project)            /// Log file path.
$(indent_namespace -o:$organization -p:$project)            std::string path;
$(indent_namespace -o:$organization -p:$project)            /// \brief
$(indent_namespace -o:$organization -p:$project)            /// true == archive log files when they reach maxLogFileSize.
$(indent_namespace -o:$organization -p:$project)            bool archive;
$(indent_namespace -o:$organization -p:$project)            /// \brief
$(indent_namespace -o:$organization -p:$project)            /// Count of archives before dropping the oldest.
$(indent_namespace -o:$organization -p:$project)            std::size_t archiveCount;
$(indent_namespace -o:$organization -p:$project)            /// \brief
$(indent_namespace -o:$organization -p:$project)            /// Max size of log file to trigger archive.
$(indent_namespace -o:$organization -p:$project)            std::size_t maxLogFileSize;

$(indent_namespace -o:$organization -p:$project)            /// \brief
$(indent_namespace -o:$organization -p:$project)            /// ctor.
$(indent_namespace -o:$organization -p:$project)            FileLogger () :
$(indent_namespace -o:$organization -p:$project)                archive (false),
$(indent_namespace -o:$organization -p:$project)                archiveCount (thekogans::util::FileLogger::DEFAULT_ARCHIVE_COUNT),
$(indent_namespace -o:$organization -p:$project)                maxLogFileSize (thekogans::util::FileLogger::DEFAULT_MAX_LOG_FILE_SIZE) {}

$(indent_namespace -o:$organization -p:$project)            /// \brief
$(indent_namespace -o:$organization -p:$project)            /// Reset the \see{thekogans::util::FileLogger} options.
$(indent_namespace -o:$organization -p:$project)            void Reset () {
$(indent_namespace -o:$organization -p:$project)                path.clear ();
$(indent_namespace -o:$organization -p:$project)                archive = false;
$(indent_namespace -o:$organization -p:$project)                archiveCount = thekogans::util::FileLogger::DEFAULT_ARCHIVE_COUNT;
$(indent_namespace -o:$organization -p:$project)                maxLogFileSize = thekogans::util::FileLogger::DEFAULT_MAX_LOG_FILE_SIZE;
$(indent_namespace -o:$organization -p:$project)            }
$(indent_namespace -o:$organization -p:$project)        } fileLogger;
$(indent_namespace -o:$organization -p:$project)        /// \brief
$(indent_namespace -o:$organization -p:$project)        /// true == log to debugger.
$(indent_namespace -o:$organization -p:$project)        bool debuggerLogger;

$(indent_namespace -o:$organization -p:$project)        /// \brief
$(indent_namespace -o:$organization -p:$project)        /// ctor.
$(indent_namespace -o:$organization -p:$project)        LoggerMgr () :
$(indent_namespace -o:$organization -p:$project)            level (thekogans::util::LoggerMgr::Info),
$(indent_namespace -o:$organization -p:$project)            decorations (thekogans::util::LoggerMgr::All),
$(indent_namespace -o:$organization -p:$project)            consoleLogger (false),
$(indent_namespace -o:$organization -p:$project)            debuggerLogger (false) {}

$(indent_namespace -o:$organization -p:$project)        /// \brief
$(indent_namespace -o:$organization -p:$project)        /// Reset the \see{thekogans::util::LoggerMgr} options.
$(indent_namespace -o:$organization -p:$project)        void Reset () {
$(indent_namespace -o:$organization -p:$project)            level = thekogans::util::LoggerMgr::Info;
$(indent_namespace -o:$organization -p:$project)            decorations = thekogans::util::LoggerMgr::All;
$(indent_namespace -o:$organization -p:$project)            consoleLogger = false;
$(indent_namespace -o:$organization -p:$project)            fileLogger.Reset ();
$(indent_namespace -o:$organization -p:$project)            debuggerLogger = false;
$(indent_namespace -o:$organization -p:$project)        }
$(indent_namespace -o:$organization -p:$project)    } loggerMgr;
$(indent_namespace -o:$organization -p:$project)    /// \brief
$(indent_namespace -o:$organization -p:$project)    /// \see{thekogans::util::LockFile} path.
$(indent_namespace -o:$organization -p:$project)    std::string lockFilePath;
$(indent_namespace -o:$organization -p:$project)    /// \brief
$(indent_namespace -o:$organization -p:$project)    /// Process install directory.
$(indent_namespace -o:$organization -p:$project)    std::string processDirectory;
$(indent_namespace -o:$organization -p:$project)    /// \brief
$(indent_namespace -o:$organization -p:$project)    /// Options file \see{thekogans::util::Directory::Watcher::WatchId}.
$(indent_namespace -o:$organization -p:$project)    thekogans::util::Directory::Watcher::WatchId watchId;
$(indent_namespace -o:$organization -p:$project)    // FIXME: Application options go here.

$(indent_namespace -o:$organization -p:$project)    /// \brief
$(indent_namespace -o:$organization -p:$project)    /// ctor.
$(indent_namespace -o:$organization -p:$project)    Options ();

$(indent_namespace -o:$organization -p:$project)private:
$(indent_namespace -o:$organization -p:$project)    // thekogans::util::CommandLineOptions
$(indent_namespace -o:$organization -p:$project)    /// \brief
$(indent_namespace -o:$organization -p:$project)    /// Called when a know option (one in options) is encoutered.
$(indent_namespace -o:$organization -p:$project)    /// \param[in] option A valid option.
$(indent_namespace -o:$organization -p:$project)    /// \param[in] value Optional option value.
$(indent_namespace -o:$organization -p:$project)    virtual void DoOption (
$(indent_namespace -o:$organization -p:$project)        char option,
$(indent_namespace -o:$organization -p:$project)        const std::string &value);
$(indent_namespace -o:$organization -p:$project)    /// \brief
$(indent_namespace -o:$organization -p:$project)    /// Called right after the options are parsed.
$(indent_namespace -o:$organization -p:$project)    /// Do one time postprocessing after options are parsed.
$(indent_namespace -o:$organization -p:$project)    virtual void Epilog ();

$(indent_namespace -o:$organization -p:$project)    // thekogans::util::Directory::Watcher::EventSink
$(indent_namespace -o:$organization -p:$project)    /// \brief
$(indent_namespace -o:$organization -p:$project)    /// Called when an entry was modified.
$(indent_namespace -o:$organization -p:$project)    /// \param[in] watchId_ Watch id of the affected directory.
$(indent_namespace -o:$organization -p:$project)    /// \param[in] directory Path of the affected directory.
$(indent_namespace -o:$organization -p:$project)    /// \param[in] entry The modified entry.
$(indent_namespace -o:$organization -p:$project)    virtual void HandleModified (
$(indent_namespace -o:$organization -p:$project)        util::Directory::Watcher::WatchId watchId_,
$(indent_namespace -o:$organization -p:$project)        const std::string &directory,
$(indent_namespace -o:$organization -p:$project)        const util::Directory::Entry &entry);

$(indent_namespace -o:$organization -p:$project)    /// \brief
$(indent_namespace -o:$organization -p:$project)    /// Parse the options file.
$(indent_namespace -o:$organization -p:$project)    void ParseOptions ();
$(indent_namespace -o:$organization -p:$project)    /// \brief
$(indent_namespace -o:$organization -p:$project)    /// Parse the \see{thekogans::util::LoggerMgr} options.
$(indent_namespace -o:$organization -p:$project)    void ParseLoggerMgr (const pugi::xml_node &node);

$(indent_namespace -o:$organization -p:$project)    /// \brief
$(indent_namespace -o:$organization -p:$project)    /// Initialize or reset the \see{thekogans::util::LoggerMgr}.
$(indent_namespace -o:$organization -p:$project)    /// \param[in] init true == Initialize, false == Reset.
$(indent_namespace -o:$organization -p:$project)    void InitLoggerMgr (bool init);
$(indent_namespace -o:$organization -p:$project)};

$(end_namespace -o:$organization -p:$project)

#endif // !defined (__${organization}_${project}_Options_h)
EOF
check_errors $?

cat > include/"${organization}"/"${project//_//}"/Version.h << EOF
#if !defined (__${organization}_${project}_Version_h)
#define __${organization}_${project}_Version_h

#include <thekogans/util/Version.h>

$(begin_namespace -o:$organization -p:$project)

$(indent_namespace -o:$organization -p:$project)/// \\brief
$(indent_namespace -o:$organization -p:$project)/// Return the compiled ${organization}_${project} version.
$(indent_namespace -o:$organization -p:$project)/// \\return Compiled ${organization}_${project} version.
$(indent_namespace -o:$organization -p:$project)const thekogans::util::Version &GetVersion ();

$(end_namespace -o:$organization -p:$project)

#endif // !defined (__${organization}_${project}_Version_h)
EOF
check_errors $?

cat > src/main.cpp << EOF
#include <string>
#include <list>
#include <iostream>
#include <thekogans/util/Types.h>
#include <thekogans/util/Constants.h>
#include <thekogans/util/LoggerMgr.h>
#include <thekogans/util/ChildProcess.h>
#include <thekogans/util/SystemInfo.h>
#include <thekogans/util/StringUtils.h>
#include <thekogans/util/MainRunLoop.h>
#include "${organization}/${project//_//}/Options.h"
#include "${organization}/${project//_//}/Version.h"

using namespace thekogans;
EOF
check_errors $?
if [ "${organization}" != "thekogans" ]; then
cat >> src/main.cpp << EOF
using namespace ${organization};
EOF
check_errors $?
fi
cat >> src/main.cpp << EOF

namespace {
    std::string GetLevelsList (const std::string &separator) {
        std::string logLevelList;
        {
            std::list<util::ui32> levels;
            util::LoggerMgr::GetLevels (levels);
            if (!levels.empty ()) {
                std::list<util::ui32>::const_iterator it = levels.begin ();
                logLevelList = util::LoggerMgr::levelTostring (*it++);
                for (std::list<util::ui32>::const_iterator end = levels.end (); it != end; ++it) {
                    logLevelList += separator + util::LoggerMgr::levelTostring (*it);
                }
            }
            else {
                logLevelList = "No LoggerMgr levels defined.";
            }
        }
        return logLevelList;
    }

    std::string GetDecorationsList (const std::string &separator) {
        std::string decorationsList;
        {
            std::list<util::ui32> decorations;
            util::LoggerMgr::GetDecorations (decorations);
            if (!decorations.empty ()) {
                std::list<util::ui32>::const_iterator it = decorations.begin ();
                decorationsList = util::LoggerMgr::decorationsTostring (*it++);
                for (std::list<util::ui32>::const_iterator end = decorations.end (); it != end; ++it) {
                    decorationsList += separator + util::LoggerMgr::decorationsTostring (*it);
                }
            }
            else {
                decorationsList = "No LoggerMgr decorations defined.";
            }
        }
        return decorationsList;
    }
}

int main (
        int argc,
        const char *argv[]) {
    ${project//_/::}::Options::Instance ().Parse (argc, argv, "hvldcfamok");
    if (${project//_/::}::Options::Instance ().help) {
        std::cout << util::FormatString (
            "%s [-h] [-v] [-l:'%s'] [-d:'%s'] [-c] [-f:'path'] [-a[:archive count]] [-m:max size] [-o] [-k:'path']\\n\\n"
            "h - Display this help message.\\n"
            "v - Display version information.\\n"
            "l - Set logging level.\\n"
            "d - Set log entry decorations. (If using more than one, wrap in \\" and separate by |).\\n"
            "c - Log to console.\\n"
            "f - Log to file (path - Path of log file).\\n"
            "a - Archive file log (archive count - Number of archives before dropping the oldest).\\n"
            "m - Max log file size before archiving.\\n"
            "o - Log to debugger console.\\n"
            "k - Use lock file to prevent multiple instances (path - Path to lock file).\\n",
            util::SystemInfo::Instance ().GetProcessPath ().c_str (),
            GetLevelsList (" | ").c_str (),
            GetDecorationsList (" | ").c_str ());
    }
    else if (${project//_/::}::Options::Instance ().version) {
        std::cout << util::FormatString (
            "%s - %s\n"
            "%s - %s\n",
            THEKOGANS_UTIL,
            util::GetVersion ().ToString ().c_str (),
            util::SystemInfo::Instance ().GetProcessPath ().c_str (),
            ${project//_/::}::GetVersion ().ToString ().c_str ());
    }
    else {
        THEKOGANS_UTIL_TRY {
            struct App {
                App () {
                    THEKOGANS_UTIL_IMPLEMENT_LOG_FLUSHER;
                    THEKOGANS_UTIL_LOG_INFO ("%s starting.\n",
                        util::SystemInfo::Instance ().GetProcessPath ().c_str ());
                    util::LockFile lockFile (${project//_/::}::Options::Instance ().lockFilePath);
                    // FIXME: Application startup code goes here.
                }
                ~App () {
                    // FIXME: Application shutdown code goes here.
                    THEKOGANS_UTIL_LOG_INFO ("%s exiting.\n",
                        util::SystemInfo::Instance ().GetProcessPath ().c_str ());
                }
                void Run () {
                    util::MainRunLoop::Instance ().Start ();
                }
            } app;
            app.Run ();
        }
        THEKOGANS_UTIL_CATCH_AND_LOG
    }
    return 0;
}
EOF
check_errors $?

cat > src/Options.cpp << EOF
#include <thekogans/util/File.h>
#include <thekogans/util/Path.h>
#include <thekogans/util/SystemInfo.h>
#include <thekogans/util/ConsoleLogger.h>
#include <thekogans/util/FileLogger.h>
#if defined (TOOLCHAIN_OS_Windows)
    #include <thekogans/util/OutputDebugStringLogger.h>
#elif defined (TOOLCHAIN_OS_OSX)
    #include <thekogans/util/NSLogLogger.h>
#endif // defined (TOOLCHAIN_OS_Windows)
#include <thekogans/util/StringUtils.h>
#include <thekogans/util/XMLUtils.h>
#include "${organization}/${project//_//}/Options.h"

using namespace thekogans;

$(begin_namespace -o:$organization -p:$project)

$(indent_namespace -o:$organization -p:$project)namespace {
$(indent_namespace -o:$organization -p:$project)    const char * const LOG_TXT = "${organization}_${project}_log.txt";
$(indent_namespace -o:$organization -p:$project)    const char * const OPTIONS_XML = "${organization}_${project}_options.xml";
$(indent_namespace -o:$organization -p:$project)    const char * const TAG_OPTIONS = "Options";
$(indent_namespace -o:$organization -p:$project)    const char * const TAG_LOGGER_MGR = "LoggerMgr";
$(indent_namespace -o:$organization -p:$project)    const char * const ATTR_LEVEL = "Level";
$(indent_namespace -o:$organization -p:$project)    const char * const ATTR_DECORATIONS = "Decorations";
$(indent_namespace -o:$organization -p:$project)    const char * const TAG_CONSOLE_LOGGER = "ConsoleLogger";
$(indent_namespace -o:$organization -p:$project)    const char * const TAG_FILE_LOGGER = "FileLogger";
$(indent_namespace -o:$organization -p:$project)    const char * const ATTR_PATH = "Path";
$(indent_namespace -o:$organization -p:$project)    const char * const ATTR_ARCHIVE = "Archive";
$(indent_namespace -o:$organization -p:$project)    const char * const ATTR_ARCHIVE_COUNT = "ArchiveCount";
$(indent_namespace -o:$organization -p:$project)    const char * const ATTR_MAX_LOG_FILE_SIZE = "MaxLogFileSize";
$(indent_namespace -o:$organization -p:$project)    const char * const TAG_DEBUGGER_LOGGER = "DebuggerLogger";
$(indent_namespace -o:$organization -p:$project)    const char * const TAG_LOCK_FILE = "LockFile";
$(indent_namespace -o:$organization -p:$project)}

$(indent_namespace -o:$organization -p:$project)#if defined (_MSC_VER)
$(indent_namespace -o:$organization -p:$project)    #pragma warning (push)
$(indent_namespace -o:$organization -p:$project)    #pragma warning (disable : 4355)
$(indent_namespace -o:$organization -p:$project)#endif // defined (_MSC_VER)

$(indent_namespace -o:$organization -p:$project)Options::Options () :
$(indent_namespace -o:$organization -p:$project)        help (false),
$(indent_namespace -o:$organization -p:$project)        version (false),
$(indent_namespace -o:$organization -p:$project)        processDirectory (
$(indent_namespace -o:$organization -p:$project)            util::Path (
$(indent_namespace -o:$organization -p:$project)                util::SystemInfo::Instance ().GetProcessPath ()).GetDirectory ()),
$(indent_namespace -o:$organization -p:$project)        watchId (
$(indent_namespace -o:$organization -p:$project)            util::Directory::Watcher::Instance ().AddWatch (
$(indent_namespace -o:$organization -p:$project)                processDirectory, *this)) {
$(indent_namespace -o:$organization -p:$project)    // FIXME: Application option initialization go here.
$(indent_namespace -o:$organization -p:$project)    ParseOptions ();
$(indent_namespace -o:$organization -p:$project)}

$(indent_namespace -o:$organization -p:$project)#if defined (_MSC_VER)
$(indent_namespace -o:$organization -p:$project)    #pragma warning (pop)
$(indent_namespace -o:$organization -p:$project)#endif // defined (_MSC_VER)

$(indent_namespace -o:$organization -p:$project)void Options::DoOption (
$(indent_namespace -o:$organization -p:$project)        char option,
$(indent_namespace -o:$organization -p:$project)        const std::string &value) {
$(indent_namespace -o:$organization -p:$project)    switch (option) {
$(indent_namespace -o:$organization -p:$project)        case 'h':
$(indent_namespace -o:$organization -p:$project)            help = true;
$(indent_namespace -o:$organization -p:$project)            break;
$(indent_namespace -o:$organization -p:$project)        case 'v':
$(indent_namespace -o:$organization -p:$project)            version = true;
$(indent_namespace -o:$organization -p:$project)            break;
$(indent_namespace -o:$organization -p:$project)        case 'l':
$(indent_namespace -o:$organization -p:$project)            loggerMgr.level =
$(indent_namespace -o:$organization -p:$project)                util::LoggerMgr::stringTolevel (value.c_str ());
$(indent_namespace -o:$organization -p:$project)            break;
$(indent_namespace -o:$organization -p:$project)        case 'd':
$(indent_namespace -o:$organization -p:$project)            loggerMgr.decorations =
$(indent_namespace -o:$organization -p:$project)                util::LoggerMgr::stringTodecorations (value.c_str ());
$(indent_namespace -o:$organization -p:$project)            break;
$(indent_namespace -o:$organization -p:$project)        case 'c':
$(indent_namespace -o:$organization -p:$project)            loggerMgr.consoleLogger = true;
$(indent_namespace -o:$organization -p:$project)            break;
$(indent_namespace -o:$organization -p:$project)        case 'f':
$(indent_namespace -o:$organization -p:$project)            loggerMgr.fileLogger.path =
$(indent_namespace -o:$organization -p:$project)                !value.empty () ? value : util::MakePath (processDirectory, LOG_TXT);
$(indent_namespace -o:$organization -p:$project)            break;
$(indent_namespace -o:$organization -p:$project)        case 'a':
$(indent_namespace -o:$organization -p:$project)            loggerMgr.fileLogger.archive = true;
$(indent_namespace -o:$organization -p:$project)            if (!value.empty ()) {
$(indent_namespace -o:$organization -p:$project)                loggerMgr.fileLogger.archiveCount =
$(indent_namespace -o:$organization -p:$project)                    util::stringTosize_t (value.c_str ());
$(indent_namespace -o:$organization -p:$project)            }
$(indent_namespace -o:$organization -p:$project)            break;
$(indent_namespace -o:$organization -p:$project)        case 'm':
$(indent_namespace -o:$organization -p:$project)            loggerMgr.fileLogger.maxLogFileSize =
$(indent_namespace -o:$organization -p:$project)                util::stringTosize_t (value.c_str ());
$(indent_namespace -o:$organization -p:$project)            break;
$(indent_namespace -o:$organization -p:$project)        case 'o':
$(indent_namespace -o:$organization -p:$project)            loggerMgr.debuggerLogger = true;
$(indent_namespace -o:$organization -p:$project)            break;
$(indent_namespace -o:$organization -p:$project)        case 'k':
$(indent_namespace -o:$organization -p:$project)            lockFilePath = value;
$(indent_namespace -o:$organization -p:$project)            break;
$(indent_namespace -o:$organization -p:$project)        // FIXME: Application options go here.
$(indent_namespace -o:$organization -p:$project)    }
$(indent_namespace -o:$organization -p:$project)}

$(indent_namespace -o:$organization -p:$project)void Options::Epilog () {
$(indent_namespace -o:$organization -p:$project)    InitLoggerMgr (true);
$(indent_namespace -o:$organization -p:$project)}

$(indent_namespace -o:$organization -p:$project)void Options::HandleModified (
$(indent_namespace -o:$organization -p:$project)        util::Directory::Watcher::WatchId watchId_,
$(indent_namespace -o:$organization -p:$project)        const std::string &directory,
$(indent_namespace -o:$organization -p:$project)        const util::Directory::Entry &entry) {
$(indent_namespace -o:$organization -p:$project)    if (watchId_ == watchId &&
$(indent_namespace -o:$organization -p:$project)            directory == processDirectory &&
$(indent_namespace -o:$organization -p:$project)            entry.name == OPTIONS_XML) {
$(indent_namespace -o:$organization -p:$project)        ParseOptions ();
$(indent_namespace -o:$organization -p:$project)    }
$(indent_namespace -o:$organization -p:$project)}

$(indent_namespace -o:$organization -p:$project)void Options::ParseOptions () {
$(indent_namespace -o:$organization -p:$project)    THEKOGANS_UTIL_TRY {
$(indent_namespace -o:$organization -p:$project)        std::string optionsFilePath =
$(indent_namespace -o:$organization -p:$project)            util::MakePath (processDirectory, OPTIONS_XML);
$(indent_namespace -o:$organization -p:$project)        if (util::Path (optionsFilePath).Exists ()) {
$(indent_namespace -o:$organization -p:$project)            pugi::xml_document document;
$(indent_namespace -o:$organization -p:$project)            pugi::xml_parse_result result =
$(indent_namespace -o:$organization -p:$project)                document.load_file (optionsFilePath.c_str ());
$(indent_namespace -o:$organization -p:$project)            if (!result) {
$(indent_namespace -o:$organization -p:$project)                THEKOGANS_UTIL_THROW_STRING_EXCEPTION (
$(indent_namespace -o:$organization -p:$project)                    "Unable to parse: %s (%s)",
$(indent_namespace -o:$organization -p:$project)                    optionsFilePath.c_str (),
$(indent_namespace -o:$organization -p:$project)                    result.description ());
$(indent_namespace -o:$organization -p:$project)            }
$(indent_namespace -o:$organization -p:$project)            pugi::xml_node node = document.document_element ();
$(indent_namespace -o:$organization -p:$project)            if (!node.empty () && std::string (node.name ()) == TAG_OPTIONS) {
$(indent_namespace -o:$organization -p:$project)                for (pugi::xml_node child = node.first_child ();
$(indent_namespace -o:$organization -p:$project)                        !child.empty (); child = child.next_sibling ()) {
$(indent_namespace -o:$organization -p:$project)                    if (child.type () == pugi::node_element) {
$(indent_namespace -o:$organization -p:$project)                        std::string childName = child.name ();
$(indent_namespace -o:$organization -p:$project)                        if (childName == TAG_LOGGER_MGR) {
$(indent_namespace -o:$organization -p:$project)                            ParseLoggerMgr (child);
$(indent_namespace -o:$organization -p:$project)                        }
$(indent_namespace -o:$organization -p:$project)                        else if (childName == TAG_LOCK_FILE) {
$(indent_namespace -o:$organization -p:$project)                            lockFilePath =
$(indent_namespace -o:$organization -p:$project)                                util::Decodestring (
$(indent_namespace -o:$organization -p:$project)                                    child.attribute (ATTR_PATH).value ());
$(indent_namespace -o:$organization -p:$project)                        }
$(indent_namespace -o:$organization -p:$project)                        // FIXME: Application options go here.
$(indent_namespace -o:$organization -p:$project)                    }
$(indent_namespace -o:$organization -p:$project)                }
$(indent_namespace -o:$organization -p:$project)            }
$(indent_namespace -o:$organization -p:$project)        }
$(indent_namespace -o:$organization -p:$project)    }
$(indent_namespace -o:$organization -p:$project)    THEKOGANS_UTIL_CATCH_AND_LOG
$(indent_namespace -o:$organization -p:$project)}

$(indent_namespace -o:$organization -p:$project)void Options::ParseLoggerMgr (const pugi::xml_node &node) {
$(indent_namespace -o:$organization -p:$project)    loggerMgr.Reset ();
$(indent_namespace -o:$organization -p:$project)    loggerMgr.level =
$(indent_namespace -o:$organization -p:$project)        util::LoggerMgr::stringTolevel (node.attribute (ATTR_LEVEL).value ());
$(indent_namespace -o:$organization -p:$project)    loggerMgr.decorations =
$(indent_namespace -o:$organization -p:$project)        util::LoggerMgr::stringTodecorations (
$(indent_namespace -o:$organization -p:$project)            node.attribute (ATTR_DECORATIONS).value ());
$(indent_namespace -o:$organization -p:$project)    for (pugi::xml_node child = node.first_child ();
$(indent_namespace -o:$organization -p:$project)            !child.empty (); child = child.next_sibling ()) {
$(indent_namespace -o:$organization -p:$project)        if (child.type () == pugi::node_element) {
$(indent_namespace -o:$organization -p:$project)            std::string childName = child.name ();
$(indent_namespace -o:$organization -p:$project)            if (childName == TAG_CONSOLE_LOGGER) {
$(indent_namespace -o:$organization -p:$project)                loggerMgr.consoleLogger = true;
$(indent_namespace -o:$organization -p:$project)            }
$(indent_namespace -o:$organization -p:$project)            else if (childName == TAG_FILE_LOGGER) {
$(indent_namespace -o:$organization -p:$project)                loggerMgr.fileLogger.path =
$(indent_namespace -o:$organization -p:$project)                    util::Decodestring (child.attribute (ATTR_PATH).value ());
$(indent_namespace -o:$organization -p:$project)                if (loggerMgr.fileLogger.path.empty ()) {
$(indent_namespace -o:$organization -p:$project)                    loggerMgr.fileLogger.path =
$(indent_namespace -o:$organization -p:$project)                        util::MakePath (processDirectory, LOG_TXT);
$(indent_namespace -o:$organization -p:$project)                }
$(indent_namespace -o:$organization -p:$project)                std::string archive =
$(indent_namespace -o:$organization -p:$project)                    std::string (child.attribute (ATTR_ARCHIVE).value ());
$(indent_namespace -o:$organization -p:$project)                if (!archive.empty ()) {
$(indent_namespace -o:$organization -p:$project)                    loggerMgr.fileLogger.archive = archive == util::XML_TRUE;
$(indent_namespace -o:$organization -p:$project)                }
$(indent_namespace -o:$organization -p:$project)                std::string archiveCount =
$(indent_namespace -o:$organization -p:$project)                    std::string (child.attribute (ATTR_ARCHIVE_COUNT).value ());
$(indent_namespace -o:$organization -p:$project)                if (!archiveCount.empty ()) {
$(indent_namespace -o:$organization -p:$project)                    loggerMgr.fileLogger.archiveCount =
$(indent_namespace -o:$organization -p:$project)                        util::stringTosize_t (archiveCount.c_str ());
$(indent_namespace -o:$organization -p:$project)                }
$(indent_namespace -o:$organization -p:$project)                std::string maxLogFileSize =
$(indent_namespace -o:$organization -p:$project)                    std::string (child.attribute (ATTR_MAX_LOG_FILE_SIZE).value ());
$(indent_namespace -o:$organization -p:$project)                if (!maxLogFileSize.empty ()) {
$(indent_namespace -o:$organization -p:$project)                    loggerMgr.fileLogger.maxLogFileSize =
$(indent_namespace -o:$organization -p:$project)                        util::stringTosize_t (maxLogFileSize.c_str ());
$(indent_namespace -o:$organization -p:$project)                }
$(indent_namespace -o:$organization -p:$project)            }
$(indent_namespace -o:$organization -p:$project)            else if (childName == TAG_DEBUGGER_LOGGER) {
$(indent_namespace -o:$organization -p:$project)                loggerMgr.debuggerLogger = true;
$(indent_namespace -o:$organization -p:$project)            }
$(indent_namespace -o:$organization -p:$project)        }
$(indent_namespace -o:$organization -p:$project)    }
$(indent_namespace -o:$organization -p:$project)    InitLoggerMgr (false);
$(indent_namespace -o:$organization -p:$project)}

$(indent_namespace -o:$organization -p:$project)void Options::InitLoggerMgr (bool init) {
$(indent_namespace -o:$organization -p:$project)    if (init) {
$(indent_namespace -o:$organization -p:$project)        THEKOGANS_UTIL_LOG_INIT (
$(indent_namespace -o:$organization -p:$project)            loggerMgr.level,
$(indent_namespace -o:$organization -p:$project)            loggerMgr.decorations);
$(indent_namespace -o:$organization -p:$project)    }
$(indent_namespace -o:$organization -p:$project)    else {
$(indent_namespace -o:$organization -p:$project)        THEKOGANS_UTIL_LOG_RESET (
$(indent_namespace -o:$organization -p:$project)            loggerMgr.level,
$(indent_namespace -o:$organization -p:$project)            loggerMgr.decorations);
$(indent_namespace -o:$organization -p:$project)    }
$(indent_namespace -o:$organization -p:$project)    if (loggerMgr.consoleLogger) {
$(indent_namespace -o:$organization -p:$project)        THEKOGANS_UTIL_LOG_ADD_LOGGER (
$(indent_namespace -o:$organization -p:$project)            util::Logger::SharedPtr (new util::ConsoleLogger));
$(indent_namespace -o:$organization -p:$project)    }
$(indent_namespace -o:$organization -p:$project)    if (!loggerMgr.fileLogger.path.empty ()) {
$(indent_namespace -o:$organization -p:$project)        THEKOGANS_UTIL_LOG_ADD_LOGGER (
$(indent_namespace -o:$organization -p:$project)            util::Logger::SharedPtr (
$(indent_namespace -o:$organization -p:$project)                new util::FileLogger (
$(indent_namespace -o:$organization -p:$project)                    loggerMgr.fileLogger.path,
$(indent_namespace -o:$organization -p:$project)                    loggerMgr.fileLogger.archive,
$(indent_namespace -o:$organization -p:$project)                    loggerMgr.fileLogger.archiveCount,
$(indent_namespace -o:$organization -p:$project)                    loggerMgr.fileLogger.maxLogFileSize)));
$(indent_namespace -o:$organization -p:$project)    }
$(indent_namespace -o:$organization -p:$project)    if (loggerMgr.debuggerLogger) {
$(indent_namespace -o:$organization -p:$project)    #if defined (TOOLCHAIN_OS_Windows)
$(indent_namespace -o:$organization -p:$project)        THEKOGANS_UTIL_LOG_ADD_LOGGER (
$(indent_namespace -o:$organization -p:$project)            util::Logger::SharedPtr (new util::OutputDebugStringLogger));
$(indent_namespace -o:$organization -p:$project)    #elif defined (TOOLCHAIN_OS_OSX)
$(indent_namespace -o:$organization -p:$project)        THEKOGANS_UTIL_LOG_ADD_LOGGER (
$(indent_namespace -o:$organization -p:$project)            util::Logger::SharedPtr (new util::NSLogLogger));
$(indent_namespace -o:$organization -p:$project)    #endif // defined (TOOLCHAIN_OS_Windows)
$(indent_namespace -o:$organization -p:$project)    }
$(indent_namespace -o:$organization -p:$project)}

$(end_namespace -o:$organization -p:$project)
EOF
check_errors $?

cat > src/Version.cpp << EOF
#include "${organization}/${project//_//}/Version.h"

using namespace thekogans;

$(begin_namespace -o:$organization -p:$project)

$(indent_namespace -o:$organization -p:$project)const util::Version &GetVersion () {
$(indent_namespace -o:$organization -p:$project)    static const util::Version *version = new util::Version (
$(indent_namespace -o:$organization -p:$project)        ${ORGANIZATION}_${PROJECT}_MAJOR_VERSION,
$(indent_namespace -o:$organization -p:$project)        ${ORGANIZATION}_${PROJECT}_MINOR_VERSION,
$(indent_namespace -o:$organization -p:$project)        ${ORGANIZATION}_${PROJECT}_PATCH_VERSION);
$(indent_namespace -o:$organization -p:$project)    return *version;
$(indent_namespace -o:$organization -p:$project)}

$(end_namespace -o:$organization -p:$project)
EOF
check_errors $?

cat > thekogans_make.xml << EOF
<thekogans_make organization = "${organization}"
                project = "${project}"
                project_type = "program"
                major_version = "0"
                minor_version = "1"
                patch_version = "0"
                guid = "`$(get_toolchain_program -o:thekogans -p:genguid)`"
                schema_version = "`$(get_toolchain_program -o:thekogans -p:make) -a:get_schema_version`">
  <dependencies>
    <dependency organization = "thekogans"
                name = "util"/>
    <!-- FIXME: Application dependencies go here. -->
  </dependencies>
  <cpp_headers prefix = "include">
    <cpp_header>\$(organization)/\$(project_directory)/Options.h</cpp_header>
    <cpp_header>\$(organization)/\$(project_directory)/Version.h</cpp_header>
    <!-- FIXME: Application headers go here. -->
  </cpp_headers>
  <cpp_sources prefix = "src">
    <cpp_source>main.cpp</cpp_source>
    <cpp_source>Options.cpp</cpp_source>
    <cpp_source>Version.cpp</cpp_source>
    <!-- FIXME: Application sources go here. -->
  </cpp_sources>
  <if condition = "\$(TOOLCHAIN_OS) == 'Windows'">
    <subsystem>Console</subsystem>
  </if>
</thekogans_make>
EOF
check_errors $?

exit 0
